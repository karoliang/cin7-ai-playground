import JSZip from 'jszip'
import { Project, ProjectFile } from '@/types'

export interface ExportOptions {
  format: 'zip' | 'github' | 'docker'
  includeDependencies: boolean
  includeReadme: boolean
  includeBuildScripts: boolean
  minifyCode: boolean
  framework?: 'react' | 'vue' | 'vanilla'
}

export interface BuildConfig {
  entryPoints: string[]
  outputDir: string
  buildCommand: string
  devCommand: string
  dependencies: Record<string, string>
  devDependencies: Record<string, string>
}

export const ProjectPackager = {
  // Generate package.json based on project files and framework
  generatePackageJson(project: Project, options: ExportOptions): any {
    const dependencies: Record<string, string> = {}
    const devDependencies: Record<string, string> = {}

    // Detect framework from files
    const hasReact = project.files.some(f =>
      f.name.includes('.jsx') ||
      f.content.includes('import React') ||
      f.content.includes('from "react"')
    )

    const hasVue = project.files.some(f =>
      f.name.includes('.vue') ||
      f.content.includes('import { createApp }')
    )

    const hasTypeScript = project.files.some(f =>
      f.name.includes('.ts') || f.name.includes('.tsx')
    )

    const hasTailwind = project.files.some(f =>
      f.content.includes('@tailwind') ||
      f.content.includes('tailwindcss')
    )

    const hasVite = project.files.some(f =>
      f.name === 'vite.config.js' ||
      f.name === 'vite.config.ts'
    )

    // Base dependencies
    if (hasReact) {
      dependencies['react'] = '^18.2.0'
      dependencies['react-dom'] = '^18.2.0'
      if (hasTypeScript) {
        dependencies['@types/react'] = '^18.2.0'
        dependencies['@types/react-dom'] = '^18.2.0'
      }
    }

    if (hasVue) {
      dependencies['vue'] = '^3.3.0'
    }

    // UI Libraries
    if (project.files.some(f => f.content.includes('@shopify/polaris'))) {
      dependencies['@shopify/polaris'] = '^12.0.0'
      dependencies['@shopify/polaris-icons'] = '^8.0.0'
    }

    // CSS Frameworks
    if (hasTailwind) {
      devDependencies['tailwindcss'] = '^3.3.0'
      devDependencies['autoprefixer'] = '^10.4.0'
      devDependencies['postcss'] = '^8.4.0'
    }

    // Build tools
    if (hasVite) {
      devDependencies['vite'] = '^5.0.0'
      if (hasTypeScript) {
        devDependencies['@vitejs/plugin-react'] = '^4.0.0'
        devDependencies['typescript'] = '^5.0.0'
      }
    } else {
      devDependencies['webpack'] = '^5.88.0'
      devDependencies['webpack-cli'] = '^5.1.0'
      devDependencies['webpack-dev-server'] = '^4.15.0'
    }

    // Add common development dependencies
    devDependencies['eslint'] = '^8.45.0'
    devDependencies['prettier'] = '^3.0.0'

    const packageJson = {
      name: project.name.toLowerCase().replace(/\s+/g, '-'),
      version: '1.0.0',
      description: project.description || `Generated by CIN7 AI Playground`,
      main: hasVite ? 'src/main.jsx' : 'src/index.js',
      scripts: {
        dev: hasVite ? 'vite' : 'webpack serve --mode development',
        build: hasVite ? 'vite build' : 'webpack --mode production',
        preview: hasVite ? 'vite preview' : 'python -m http.server dist',
        lint: 'eslint src --ext js,jsx,ts,tsx',
        format: 'prettier --write src/**/*.{js,jsx,ts,tsx,css,md}'
      },
      dependencies: options.includeDependencies ? dependencies : {},
      devDependencies: options.includeDependencies ? devDependencies : {},
      keywords: ['cin7', 'ai-generated', hasReact ? 'react' : hasVue ? 'vue' : 'vanilla'],
      author: 'CIN7 AI Playground',
      license: 'MIT'
    }

    return packageJson
  },

  // Generate README.md
  generateReadme(project: Project, options: ExportOptions): string {
    const hasReact = project.files.some(f => f.name.includes('.jsx'))
    const hasVue = project.files.some(f => f.name.includes('.vue'))
    const hasVite = project.files.some(f => f.name === 'vite.config.js' || f.name === 'vite.config.ts')

    const framework = hasReact ? 'React' : hasVue ? 'Vue' : 'Vanilla JavaScript'
    const buildTool = hasVite ? 'Vite' : 'Webpack'

    return `# ${project.name}

${project.description || 'A project generated by CIN7 AI Playground'}

## üöÄ Quick Start

### Prerequisites
- Node.js 18+ and npm

### Installation
\`\`\`bash
${options.includeDependencies ? 'npm install' : '# Install dependencies manually'}
\`\`\`

### Development
\`\`\`bash
npm run dev
\`\`\`

### Production Build
\`\`\`bash
npm run build
\`\`\`

### Preview
\`\`\`bash
npm run preview
\`\`\`

## üõ†Ô∏è Tech Stack

- **Framework**: ${framework}
- **Build Tool**: ${buildTool}
- **UI Library**: ${project.files.some(f => f.content.includes('@shopify/polaris')) ? 'Shopify Polaris' : 'Custom CSS'}
- **Language**: ${project.files.some(f => f.name.includes('.ts') || f.name.includes('.tsx')) ? 'TypeScript' : 'JavaScript'}

## üìÅ Project Structure

\`\`\`
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ components/     # Reusable UI components
‚îÇ   ‚îú‚îÄ‚îÄ pages/         # Page components
‚îÇ   ‚îú‚îÄ‚îÄ utils/         # Utility functions
‚îÇ   ‚îú‚îÄ‚îÄ styles/        # CSS and styling files
‚îÇ   ‚îî‚îÄ‚îÄ main.${hasReact ? 'jsx' : 'js'}  # Application entry point
‚îú‚îÄ‚îÄ public/            # Static assets
‚îú‚îÄ‚îÄ dist/             # Build output
‚îú‚îÄ‚îÄ package.json      # Dependencies and scripts
${hasVite ? '‚îú‚îÄ‚îÄ vite.config.js   # Vite configuration' : '‚îú‚îÄ‚îÄ webpack.config.js # Webpack configuration'}
${project.files.some(f => f.content.includes('@shopify/polaris')) ? '‚îú‚îÄ‚îÄ polaris.css      # Polaris styles' : ''}
‚îî‚îÄ‚îÄ README.md         # This file
\`\`\`

## üé® Features

- **AI-Powered Development**: Built with CIN7 AI Playground
- **Modern Build System**: Fast development and optimized production builds
- **Component Architecture**: Reusable, maintainable components
- **Responsive Design**: Works on all device sizes
${project.files.some(f => f.content.includes('@shopify/polaris')) ? '- **CIN7 Design System**: Consistent with CIN7 branding' : ''}

## üìù Development Scripts

- \`npm run dev\` - Start development server
- \`npm run build\` - Build for production
- \`npm run preview\` - Preview production build
- \`npm run lint\` - Run ESLint
- \`npm run format\` - Format code with Prettier

## ü§ù Contributing

This project was generated by AI. Feel free to modify and enhance it according to your needs.

## üìÑ License

MIT License - feel free to use this project for commercial or personal use.

## üîó Links

- [CIN7 AI Playground](https://cin7-ai-playground.com)
- [CIN7 Documentation](https://docs.cin7.com)
- [Support](https://support.cin7.com)

---

*Generated on ${new Date().toLocaleDateString()} by CIN7 AI Playground*
`
  },

  // Generate .gitignore
  generateGitignore(): string {
    return `# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Production builds
dist/
build/
out/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE and editor files
.vscode/
.idea/
*.swp
*.swo
*~

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
logs
*.log

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/

# Temporary folders
tmp/
temp/

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# next.js build output
.next

# nuxt.js build output
.nuxt

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/
`
  },

  // Generate build configuration files
  generateBuildConfig(project: Project, options: ExportOptions): Record<string, string> {
    const configs: Record<string, string> = {}
    const hasReact = project.files.some(f => f.name.includes('.jsx'))
    const hasTypeScript = project.files.some(f => f.name.includes('.ts') || f.name.includes('.tsx'))
    const hasVite = project.files.some(f => f.name === 'vite.config.js' || f.name === 'vite.config.ts')

    if (hasVite && !project.files.some(f => f.name === 'vite.config.js' || f.name === 'vite.config.ts')) {
      // Generate Vite config
      const viteConfig = hasTypeScript ? `import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
    open: true
  },
  build: {
    outDir: 'dist',
    sourcemap: true
  },
  resolve: {
    alias: {
      '@': '/src'
    }
  }
})` : `import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
    open: true
  },
  build: {
    outDir: 'dist',
    sourcemap: true
  },
  resolve: {
    alias: {
      '@': '/src'
    }
  }
})`

      configs['vite.config.js'] = viteConfig
    }

    // Generate ESLint config
    const eslintConfig = `{
  "extends": [
    "eslint:recommended",
    ${hasReact ? '"@typescript-eslint/recommended",' : ''}
    ${hasReact ? '"plugin:react/recommended",' : ''}
    ${hasReact ? '"plugin:react-hooks/recommended"' : ''}
  ],
  "parser": ${hasTypeScript ? '"@typescript-eslint/parser"' : '"@babel/eslint-parser"'},
  "plugins": [${hasReact ? '"react",' : ''} ${hasTypeScript ? '"@typescript-eslint"' : ''}],
  "env": {
    "browser": true,
    "es2021": true,
    "node": true
  },
  "parserOptions": {
    ${hasTypeScript ? '"ecmaVersion": "latest",' : ''}
    ${hasTypeScript ? '"sourceType": "module",' : ''}
    ${hasReact ? '"ecmaFeatures": {"jsx": true},' : ''}
    ${hasTypeScript ? '"project": "./tsconfig.json"' : ''}
  },
  ${hasReact ? '"settings": {"react": {"version": "detect"}},' : ''}
  "rules": {
    ${hasReact ? '"react/react-in-jsx-scope": "off",' : ''}
    "no-unused-vars": "warn",
    "no-console": "warn"
  }
}`

    configs['.eslintrc.json'] = eslintConfig

    // Generate Prettier config
    const prettierConfig = `{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false
}`

    configs['.prettierrc'] = prettierConfig

    // Generate TypeScript config if needed
    if (hasTypeScript && !project.files.some(f => f.name === 'tsconfig.json')) {
      const tsConfig = `{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["dom", "dom.iterable", "ES6"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": [
    "src"
  ]
}`

      configs['tsconfig.json'] = tsConfig
    }

    return configs
  },

  // Export project as ZIP file
  async exportAsZip(project: Project, options: ExportOptions): Promise<Blob> {
    const zip = new JSZip()

    // Add project files
    project.files.forEach(file => {
      let content = file.content
      if (options.minifyCode && (file.name.endsWith('.js') || file.name.endsWith('.jsx'))) {
        // Simple minification (in production, use a proper minifier)
        content = content
          .replace(/\/\*[\s\S]*?\*\//g, '') // Remove block comments
          .replace(/\/\/.*$/gm, '') // Remove line comments
          .replace(/\s+/g, ' ') // Collapse whitespace
          .trim()
      }
      zip.file(file.name, content)
    })

    // Add configuration files
    if (options.includeDependencies) {
      zip.file('package.json', JSON.stringify(this.generatePackageJson(project, options), null, 2))
    }

    if (options.includeReadme) {
      zip.file('README.md', this.generateReadme(project, options))
    }

    zip.file('.gitignore', this.generateGitignore())

    // Add build configurations
    const buildConfigs = this.generateBuildConfig(project, options)
    Object.entries(buildConfigs).forEach(([filename, content]) => {
      zip.file(filename, content as string)
    })

    // Add public directory with index.html if it doesn't exist
    const hasIndexHtml = project.files.some(f => f.name === 'index.html')
    if (!hasIndexHtml) {
      const hasReact = project.files.some(f => f.name.includes('.jsx'))
      const indexHtml = `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>${project.name}</title>
    ${project.files.some(f => f.content.includes('@shopify/polaris')) ? '<link rel="stylesheet" href="https://unpkg.com/@shopify/polaris@12/build/esm/styles.css" />' : ''}
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.${hasReact ? 'jsx' : 'js'}"></script>
  </body>
</html>`

      zip.file('index.html', indexHtml)
    }

    return await zip.generateAsync({ type: 'blob' })
  },

  // Export to GitHub (placeholder for future implementation)
  async exportToGitHub(project: Project, options: ExportOptions, repoConfig: {
    repositoryName: string
    description: string
    isPrivate: boolean
    token?: string
  }): Promise<{ url: string; success: boolean; error?: string }> {
    try {
      // This would integrate with GitHub API
      // For now, return a placeholder response
      return {
        url: `https://github.com/user/${repoConfig.repositoryName}`,
        success: false,
        error: 'GitHub export not implemented yet'
      }
    } catch (error) {
      return {
        url: '',
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      }
    }
  },

  // Export as Docker container (placeholder for future implementation)
  async exportAsDocker(project: Project, options: ExportOptions): Promise<Blob> {
    const zip = new JSZip()

    // Add project files (same as ZIP export)
    const projectZip = await this.exportAsZip(project, options)
    zip.file('project.zip', projectZip)

    // Add Dockerfile
    const hasReact = project.files.some(f => f.name.includes('.jsx'))
    const dockerfile = `FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./
RUN npm ci --only=production

# Copy project files
COPY . .

# Build the application
RUN npm run build

# Expose port
EXPOSE 3000

# Serve the application
CMD ["npm", "run", "preview"]
`

    zip.file('Dockerfile', dockerfile)

    // Add docker-compose.yml
    const dockerCompose = `version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
    volumes:
      - ./dist:/app/dist
`

    zip.file('docker-compose.yml', dockerCompose)

    return await zip.generateAsync({ type: 'blob' })
  },

  // Get estimated export size
  getExportSize(project: Project, options: ExportOptions): number {
    let totalSize = 0

    // Calculate project files size
    project.files.forEach(file => {
      totalSize += new Blob([file.content]).size
    })

    // Estimate configuration files
    totalSize += 2048 // package.json
    if (options.includeReadme) totalSize += 4096 // README.md
    totalSize += 1024 // .gitignore
    totalSize += 3072 // Build configs
    totalSize += 2048 // index.html

    return totalSize
  }
}